" ------------------------------------------------------------
" VimåŸºæœ¬è¨­å®š
" ------------------------------------------------------------
" ãƒªãƒ¼ãƒ€ãƒ¼ã‚­ãƒ¼ã®è¨­å®š
let mapleader = ","

" ãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—ã¨ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã®è¨­å®š
" ãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—ã®æ¤œå‡ºã€ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã¨ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’æœ‰åŠ¹åŒ–
filetype plugin indent on

" æ¤œç´¢è¨­å®š
" æ¤œç´¢çµæœã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤º
set hlsearch
" æ¤œç´¢æ™‚ã«å¤§æ–‡å­—å°æ–‡å­—ã‚’åŒºåˆ¥ã—ãªã„
set ignorecase
" æ¤œç´¢ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¤§æ–‡å­—ã‚’å«ã‚€å ´åˆã¯å¤§æ–‡å­—å°æ–‡å­—ã‚’åŒºåˆ¥
set smartcase
" ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ã‚¿ãƒ«ã‚µãƒ¼ãƒã‚’æœ‰åŠ¹åŒ–ï¼ˆæ¤œç´¢æ–‡å­—å…¥åŠ›æ™‚ã«éšæ™‚æ¤œç´¢ï¼‰
set incsearch

" çŸ©å½¢é¸æŠæ™‚ã®ä»®æƒ³ç·¨é›†ã‚’æœ‰åŠ¹åŒ–
set virtualedit=block

" æŠ˜ã‚ŠãŸãŸã¿è¨­å®š
" ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã«åŸºã¥ã„ã¦æŠ˜ã‚ŠãŸãŸã¿ã‚’è¡Œã†
set foldmethod=indent
" ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã™ã¹ã¦ã®æŠ˜ã‚ŠãŸãŸã¿ã‚’é–‹ã
set foldlevel=99

" ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³è£œå®Œã®è¨­å®š
" è£œå®Œãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’æ”¹å–„
set wildmenu wildoptions=pum
" ãƒ•ã‚¡ã‚¤ãƒ«åè£œå®Œã§å¤§æ–‡å­—å°æ–‡å­—ã‚’åŒºåˆ¥ã—ãªã„
set wildignorecase

" è¡Œç•ªå·ã‚’ç›¸å¯¾çš„ã«è¡¨ç¤º
set relativenumber

" ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã®ç„¡åŠ¹åŒ–
" ã‚¹ãƒ¯ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ãªã„
set noswapfile
" ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ãªã„
set nobackup
" ã‚¢ãƒ³ãƒ‰ã‚¥ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ãªã„
set noundofile

" ãƒã‚¦ã‚¹æ“ä½œã‚’æœ‰åŠ¹åŒ–
set mouse=a

" ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚·ã‚§ãƒ«ã®è¨­å®š
set shell=bash

" ãƒ¤ãƒ³ã‚¯ã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«é€ä¿¡
augroup text_yank_post
  au!
  autocmd TextYankPost * :call system('clip -i', @")
augroup END

" ------------------------------------------------------------
" cursor
" ------------------------------------------------------------
" https://qiita.com/Linda_pp/items/9e0c94eb82b18071db34
if has('vim_starting')
  let &t_SI .= "\e[6 q" " Insert mode: non-blinking vertical bar cursor
  let &t_EI .= "\e[2 q" " Normal mode: non-blinking block cursor
  let &t_SR .= "\e[4 q" " Replace mode: non-blinking underline cursor
endif

" ------------------------------------------------------------
" indent
" ------------------------------------------------------------
augroup fileTypeIndent
  autocmd!
  " Ruby (2ã‚¹ãƒšãƒ¼ã‚¹ - Rubyã‚¹ã‚¿ã‚¤ãƒ«ã‚¬ã‚¤ãƒ‰æ¨å¥¨)
  autocmd FileType ruby setlocal expandtab shiftwidth=2 softtabstop=2

  " Go (ã‚¿ãƒ– - å…¬å¼ãƒ„ãƒ¼ãƒ« go fmt ã®æ¨™æº–)
  autocmd FileType go setlocal noexpandtab shiftwidth=4 softtabstop=4 tabstop=4

  " TypeScript/JavaScript (2ã‚¹ãƒšãƒ¼ã‚¹ - Google/Airbnb ã‚¹ã‚¿ã‚¤ãƒ«ã‚¬ã‚¤ãƒ‰)
  autocmd FileType typescript setlocal expandtab shiftwidth=2 softtabstop=2
  autocmd FileType javascript setlocal expandtab shiftwidth=2 softtabstop=2
  autocmd FileType typescriptreact setlocal expandtab shiftwidth=2 softtabstop=2

  " Vim (2ã‚¹ãƒšãƒ¼ã‚¹ - ä¸€èˆ¬çš„ãªæ…£ç¿’)
  autocmd FileType vim setlocal expandtab shiftwidth=2 softtabstop=2

  " YAML (2ã‚¹ãƒšãƒ¼ã‚¹ - YAMLä»•æ§˜ã®å¯èª­æ€§æ¨å¥¨)
  autocmd FileType yaml setlocal expandtab shiftwidth=2 softtabstop=2
  autocmd FileType yml setlocal expandtab shiftwidth=2 softtabstop=2

  " JSON (2ã‚¹ãƒšãƒ¼ã‚¹ - ä¸€èˆ¬çš„ãªæ…£ç¿’)
  autocmd FileType json setlocal expandtab shiftwidth=2 softtabstop=2

  " CSS (2ã‚¹ãƒšãƒ¼ã‚¹ - Google/Airbnb ã‚¹ã‚¿ã‚¤ãƒ«ã‚¬ã‚¤ãƒ‰)
  autocmd FileType css setlocal expandtab shiftwidth=2 softtabstop=2
augroup END

" ------------------------------------------------------------
" path
" ------------------------------------------------------------
set path+=api/.
set path+=api/app/**
set path+=api/bin/**
set path+=api/config/**
set path+=api/db/**
set path+=api/gen/**
set path+=api/lib/**
set path+=api/spec/**

set path+=frontend/.
set path+=frontend/src/**
set path+=frontend/tests/**

set wildignore+=**/node_modules/**
set wildignore+=**/tmp/**
set wildignore+=**/dist/**
set wildignore+=**/build/**
set wildignore+=**/.git/**
set wildignore+=*.log
set wildignore+=*.tmp
set wildignore+=*.png,*.jpg,*.gif
set wildignore+=*.pdf
set wildignore+=*.zip,*.tar.gz

" ------------------------------------------------------------
" plugin
" ------------------------------------------------------------
" incompatible plugins
if has('syntax') && has('eval')
  packadd! matchit
end

call plug#begin('~/.shared_cache/.vim/plugged')
  Plug 'vim-jp/vimdoc-ja'
  Plug 'morhetz/gruvbox'
  Plug 'itchyny/lightline.vim'
    Plug 'shinchu/lightline-gruvbox.vim'
  Plug 'ctrlpvim/ctrlp.vim'
    Plug 'mattn/ctrlp-matchfuzzy'
    Plug 'mattn/ctrlp-launcher'
  Plug 'tpope/vim-fugitive'
  Plug 'airblade/vim-gitgutter'
  Plug 'tyru/caw.vim'
  Plug 'prabirshrestha/vim-lsp'
  Plug 'mattn/vim-lsp-settings'
  Plug 'prabirshrestha/asyncomplete.vim'
  Plug 'prabirshrestha/asyncomplete-lsp.vim'
  Plug 'thinca/vim-quickrun'
  Plug 'vim-denops/denops.vim'
  Plug 'nathanaelkane/vim-indent-guides'
call plug#end()

" auto plug install
augroup auto_plug_install
  au!
  autocmd VimEnter * if len(filter(values(g:plugs), '!isdirectory(v:val.dir)'))
    \| PlugInstall --sync | source $MYVIMRC
  \| endif
augroup END

" ------------------------------------------------------------
" colorscheme
" ------------------------------------------------------------
set background=dark
colorscheme gruvbox

" ------------------------------------------------------------
" lightline
" ------------------------------------------------------------
set laststatus=2

if !has('gui_running')
  set t_Co=256
endif

let g:lightline = {
  \ 'colorscheme': 'gruvbox',
  \ 'active': {
  \   'left': [ [ 'mode', 'paste' ],
  \             [ 'gitbranch', 'readonly', 'filename', 'modified' ],
  \           ],
  \   'right': [
  \     ['lineinfo'],
  \     ['percent'],
  \     ['fileformat', 'fileencoding', 'filetype', 'winbufnr']
  \   ]
  \ },
  \ 'inactive': {
  \   'right': [ [ 'lineinfo' ],
  \              [ 'percent' ],
  \              [ 'winbufnr' ] ]
  \ },
  \ 'component_function': {
  \   'gitbranch': 'fugitive#head',
  \ },
  \ 'component': {
  \   'winbufnr': 'win:%{winnr()} buf:%n'
  \ },
  \ }

" ------------------------------------------------------------
" vim-indent-guides
" ------------------------------------------------------------
" Vimèµ·å‹•æ™‚ã«ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚¬ã‚¤ãƒ‰ã‚’æœ‰åŠ¹åŒ–
let g:indent_guides_enable_on_vim_startup = 1

" ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚¬ã‚¤ãƒ‰ã‚’è¡¨ç¤ºã—å§‹ã‚ã‚‹ãƒ¬ãƒ™ãƒ« (2ã‹ã‚‰é–‹å§‹)
let g:indent_guides_start_level = 2

" ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã®å¹…ã‚’1æ–‡å­—åˆ†ã«è¨­å®š
let g:indent_guides_guide_size = 1

" ------------------------------------------------------------
" ctrlp
" ------------------------------------------------------------
let g:ctrlp_match_func = {'match': 'ctrlp_matchfuzzy#matcher'}
let g:ctrlp_map = '<leader><leader>'
let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files -co --exclude-standard']
nnoremap <leader>b :CtrlPBuffer<cr>
nnoremap <leader>t :CtrlPTag<cr>
nnoremap <leader>f :CtrlPBufTag<cr>
nnoremap <leader>q :CtrlPQuickfix<cr>
nnoremap <leader>m :CtrlPMRUFiles<cr>

" ------------------------------------------------------------
" ctrlp-launcher
" ------------------------------------------------------------
nnoremap <leader>e :<c-u>CtrlPLauncher<cr>
let g:ctrlp_launcher_file = '~/.vim/config/.ctrlp-launcher'

" ------------------------------------------------------------
" ctags
" ------------------------------------------------------------
" see: https://qiita.com/aratana_tamutomo/items/59fb4c377863a385e032
set tags=.tags;$HOME

" ctagsã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’å…±é€šå®šç¾©
let s:ctags_options = '--exclude=node_modules --exclude=.git --exclude=*.css --exclude=*.json -R -f '

" ã‚¿ã‚°ç”Ÿæˆã‚³ãƒãƒ³ãƒ‰
command! MakeTags call system('ctags ' . s:ctags_options . '.tags')

function! s:execute_ctags() abort
  let tag_name = '.tags'
  let tags_path = findfile(tag_name, '.;')
  if tags_path ==# ''
    return
  endif

  " ã‚¿ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹ã‚’å–å¾—
  " `:p:h`ã®éƒ¨åˆ†ã¯ã€:h filename-modifiersã§ç¢ºèª
  let tags_dirpath = fnamemodify(tags_path, ':p:h')
  " è¦‹ã¤ã‹ã£ãŸã‚¿ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ç§»å‹•ã—ã¦ã€ctagsã‚’ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å®Ÿè¡Œï¼ˆã‚¨ãƒ©ãƒ¼å‡ºåŠ›ç ´æ£„ï¼‰
  execute 'silent !cd' tags_dirpath '&& ctags ' . s:ctags_options . tag_name . ' 2> /dev/null &'
endfunction

augroup update_ctags
  au!
  autocmd BufWritePost * call s:execute_ctags()
augroup END

" ------------------------------------------------------------
" denops
" ------------------------------------------------------------

" ------------------------------------------------------------
" vimdoc-ja
" ------------------------------------------------------------
" vim help japanese
set helplang=ja,en

" ------------------------------------------------------------
" netrw
" ------------------------------------------------------------
" ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¡¨ç¤ºè¨­å®š
let g:netrw_liststyle = 3    " ãƒ„ãƒªãƒ¼è¡¨ç¤ºã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«
let g:netrw_banner = 0       " ãƒãƒŠãƒ¼ã‚’éè¡¨ç¤º
let g:netrw_winsize = 25

" Netrwã®ãƒˆã‚°ãƒ«åˆ¶å¾¡ç”¨
let g:NetrwIsOpen = 0

" Netrwã‚’ãƒˆã‚°ãƒ«ã§è¡¨ç¤º/éè¡¨ç¤ºã™ã‚‹é–¢æ•°
function! ToggleNetrw() abort
   if g:NetrwIsOpen
       " é–‹ã„ã¦ã„ã‚‹å ´åˆã¯é–‰ã˜ã‚‹
       let i = bufnr("$")
       while (i >= 1)
           if (getbufvar(i, "&filetype") == "netrw")
               silent exe "bwipeout " . i
           endif
           let i-=1
       endwhile
       let g:NetrwIsOpen = 0
   else
       " é–‰ã˜ã¦ã„ã‚‹å ´åˆã¯é–‹ã
       let g:NetrwIsOpen = 1
       silent Vex
   endif
endfunction

" ãƒ‘ã‚¹é–¢é€£ã®æ“ä½œã‚’è¡Œã†é–¢æ•°
function! s:GetNetrwPath() abort
   " ç¾åœ¨ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ„ãƒªãƒ¼ã®ãƒ‘ã‚¹ã‚’å–å¾—
   let l:dirpath = netrw#Call('NetrwTreePath', w:netrw_treetop)
   " ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã®ã‚¢ã‚¤ãƒ†ãƒ åã‚’å–å¾—
   let l:filename = netrw#Call('NetrwGetWord')
   
   " ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å ´åˆï¼ˆæœ«å°¾ãŒ/ï¼‰ã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹ã®ã¿ã‚’è¿”ã™
   " ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹ã¨ãƒ•ã‚¡ã‚¤ãƒ«åã‚’çµåˆ
   return l:filename =~ '/$' ? l:dirpath : l:dirpath . '/' . l:filename
endfunction

" ã‚¨ãƒ³ã‚¿ãƒ¼ã‚­ãƒ¼æŠ¼ä¸‹æ™‚ã®å‡¦ç†
function! s:HandleEnter() abort
   let l:path = s:GetNetrwPath()

   if isdirectory(l:path)
       " ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å ´åˆã¯æ¨™æº–ã®netrwæ“ä½œã‚’å®Ÿè¡Œ
       execute "normal \<Plug>NetrwLocalBrowseCheck"
       return
   endif

   " ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆã¯æŒ‡å®šã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã§é–‹ã
   call s:OpenFileInSharedWindow('edit')
endfunction

" ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ãå‡¦ç†
function! s:OpenFileInSharedWindow(mode) abort
   let l:path = s:GetNetrwPath()
   let l:prevwin = winnr('#')  " å‰å›ã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ç•ªå·ã‚’å–å¾—

   " ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯æ–°è¦ä½œæˆ
   if l:prevwin == 0
       vertical rightbelow new
       vertical resize 80
   else
       " æ—¢å­˜ã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ä½¿ç”¨
       execute l:prevwin . 'wincmd w'
   endif

   " ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
   execute 'edit ' . fnameescape(l:path)

   " ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã¯netrwã«æˆ»ã‚‹
   if a:mode ==# 'preview'
       wincmd p
   endif
endfunction

" ã‚­ãƒ¼ãƒãƒƒãƒ”ãƒ³ã‚°ã®è¨­å®š
function! s:set_netrw_mappings() abort
   if !exists('g:loaded_netrwPlugin')
       return
   endif
   nmap <buffer> p :call <SID>OpenFileInSharedWindow('preview')<CR>
   nmap <buffer> <CR> :call <SID>HandleEnter()<CR>
endfunction

" åˆæœŸè¨­å®š
augroup InitNetrw
   autocmd!
   autocmd FileType netrw call s:set_netrw_mappings()
augroup END

" ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚­ãƒ¼ãƒãƒƒãƒ”ãƒ³ã‚°
" == ã§netrwã‚’ãƒˆã‚°ãƒ«
noremap <silent>== :call ToggleNetrw()<CR>

" ------------------------------------------------------------
" gitgutter
" ------------------------------------------------------------
" gitgutter update faster
set updatetime=50

let g:gitgutter_sign_added = '+'
let g:gitgutter_sign_modified = '>'
let g:gitgutter_sign_removed = '-'
let g:gitgutter_sign_removed_first_line = '^'
let g:gitgutter_sign_modified_removed = '<'

" ref: https://teratail.com/questions/29844#reply-46767
augroup vimrc_vim_gitgutter
  au!
  autocmd VimEnter,ColorScheme * highlight SignColumn guibg=NONE ctermbg=NONE
  autocmd VimEnter,ColorScheme * highlight GitGutterAdd guibg=NONE ctermbg=NONE guifg=#000900 ctermfg=2
  autocmd VimEnter,ColorScheme * highlight GitGutterChange guibg=NONE ctermbg=NONE guifg=#bbbb00 ctermfg=3
  autocmd VimEnter,ColorScheme * highlight GitGutterDelete guibg=NONE ctermbg=NONE guifg=#ff2222 ctermfg=1
augroup END

" ------------------------------------------------------------
" asyncomplete
" ------------------------------------------------------------
" Added key mappings for asyncomplete
imap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
imap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
imap <expr> <cr>    pumvisible() ? asyncomplete#close_popup() : "\<cr>"

let g:asyncomplete_popup_delay = 100

" ------------------------------------------------------------
" lsp
" ------------------------------------------------------------
let g:lsp_diagnostics_enabled = 1
let g:lsp_diagnostics_echo_cursor = 1
let g:lsp_diagnostics_echo_delay = 10
let g:lsp_diagnostics_float_cursor = 1
let g:lsp_diagnostics_signs_enabled = 1
let g:lsp_diagnostics_virtual_text_enabled = 0
let g:lsp_diagnostics_signs_delay = 10
let g:lsp_diagnostics_signs_insert_mode_enabled = 0
" let g:lsp_diagnostics_signs_error = {'text': 'ğŸ›'}
" let g:lsp_diagnostics_signs_warning = {'text': 'ğŸª°'}
" let g:lsp_diagnostics_signs_hint = {'text': 'ğŸ’¡'}
" let g:lsp_diagnostics_signs_information = {'text': 'â„¹ï¸'}
let g:lsp_diagnostics_highlights_delay = 10
let g:lsp_diagnostics_highlights_insert_mode_enabled = 0
let g:lsp_document_code_action_signs_enabled = 0

let g:lsp_settings_servers_dir='~/.shared_cache/.vim/servers'
let g:lsp_settings_filetype_ruby = ['solargraph']

" debug
" let g:lsp_log_verbose = 1 " ãƒ­ã‚°ã‚’æœ‰åŠ¹ã«ã™ã‚‹
" let g:lsp_log_file = expand('~/.shared_cache/.vim/vim-lsp.log') " ãƒ­ã‚°ã®å‡ºåŠ›å…ˆ

" vim-lsp ãŒãƒãƒƒãƒ•ã‚¡ã§æœ‰åŠ¹ã«ãªã£ãŸã¨ãã«å®Ÿè¡Œã•ã‚Œã‚‹é–¢æ•°
" ãƒãƒƒãƒ•ã‚¡ãƒ­ãƒ¼ã‚«ãƒ«ãªã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰ã‚„ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’æŒ‡å®š
" See: https://mattn.kaoriya.net/software/vim/20191231213507.htm
function! s:on_lsp_buffer_enabled() abort
  let g:lsp_format_sync_timeout = 1000

  " golang
  " ãƒãƒƒãƒ•ã‚¡ä¿å­˜æ™‚ã«æ¯å›ã€Œimportè£œå®Œã€ã¨ã€Œã‚³ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã€ã‚’å®Ÿè¡Œ
  autocmd BufWritePre *.go call execute(['LspCodeActionSync source.organizeImports', 'LspDocumentFormatSync'])
endfunction

augroup lsp_install
  au!
  autocmd User lsp_buffer_enabled call s:on_lsp_buffer_enabled()
augroup END

" ------------------------------------------------------------
" session
" ------------------------------------------------------------
" augroup SessionAutocommands
"   au!
" 
"   autocmd VimEnter * nested call <SID>RestoreSessionWithConfirm()
"   autocmd VimLeave * execute 'SaveSession'
" augroup END

command! RestoreSession :source ~/.shared_cache/.vim/.session
command! SaveSession    :mksession! ~/.shared_cache/.vim/.session

" Restore session with confirm
" function! s:RestoreSessionWithConfirm()
"   let msg = 'Do you want to restore previous session?'
" 
"   if !argc() && confirm(msg, "&Yes\n&No", 1, 'Question') == 1
"     execute 'RestoreSession'
"   endif
" endfunction

" ------------------------------------------------------------
" QuickRun
" ------------------------------------------------------------
let g:quickrun_config = {}
let g:quickrun_config['go'] = {
    \ 'command': 'go',
    \ 'cmdopt': 'run',
    \ 'exec': 'go run %S'
    \ }

" ------------------------------------------------------------
" filetype
" ------------------------------------------------------------
augroup ts_react_add_path
  au!
  autocmd FileType typescriptreact :setl path+=**;/features/**
  autocmd FileType typescriptreact :setl includeexpr=substitute(v:fname,'^/','','')
augroup END

" ------------------------------------------------------------
" key mappings
" ------------------------------------------------------------
" highlight off
nmap <silent> <Esc><Esc> :<C-u>nohlsearch<CR><Esc>

" vimrcã‚’é–‹ã
nmap <leader>v :e $MYVIMRC<CR>

" This line maps the 'q' key to a silent action
map q <silent>

" Gitç®¡ç†ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ç›¸å¯¾ãƒ‘ã‚¹ã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼
command! CopyGitPath :let @"='.' . substitute(expand('%:p'), trim(system('git rev-parse --show-toplevel')), '', '') | echo @" | call system('clip -i', @")
nnoremap <leader>c :CopyGitPath<cr>

" quickfix
nnoremap <silent> cn :cn<CR>
nnoremap <silent> cp :cp<CR>

" buffers and quickfix
function! ToggleQuickFix()
  if empty(filter(getwininfo(), 'v:val.quickfix'))
    copen
  else
    cclose
  endif
endfunction
nnoremap <leader>w :call ToggleQuickFix()<cr>
nnoremap <leader>d :bd<cr>

" searching ang grepping
nnoremap <leader>g :copen<cr>:Ggrep!<SPACE>
nnoremap K :Ggrep "\b<C-R><C-W>\b"<cr>:cw<cr>

" ctags
nnoremap <C-]> g<C-]>

function! GitShowCursorPullRequest()
  let l:word = expand('<cword>')
  let l:get_pr_number = "gh api graphql
      \ -F owner=':owner' -F repo=':repo' -F hash=" . l:word . "
      \ -f query='query($repo:String!, $owner:String!, $hash:String) { repository(name: $repo, owner: $owner) { object(expression: $hash) { ... on Commit {associatedPullRequests(first: 1) { edges { node { number } } } } } } }'
      \ | jq '.data.repository.object.associatedPullRequests.edges[0].node.number'"
  let l:pr_number = system(l:get_pr_number)

  echo "pr_number: " . l:pr_number
  if match(l:pr_number, 'null\n') != -1
    echo "Pull Request not found."
    return
  endif

  let l:get_pr_url = "gh api graphql
      \ -F owner=':owner' -F repo=':repo' -F number=" . str2nr(l:pr_number) . "
      \ -f query='query($repo:String!, $owner:String!, $number:Int!) { repository(name: $repo, owner: $owner) { pullRequest(number: $number) { url } } }'
      \ | jq '.data.repository.pullRequest.url'"
  let l:pr_url = system(l:get_pr_url)
  echo "open: " . l:pr_url | let @"=l:pr_url | call system('chrome -i', @")
endfunction

command! ShowPullRequest :call GitShowCursorPullRequest()
nnoremap go :ShowPullRequest<cr>

" å¯¾å¿œã—ãŸspecãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
command! OpenSpec :call OpenSpecFile()

function! OpenSpecFile()
  " ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’å–å¾—
  let current_file = expand('%:p')

  " app/ ã‚’ spec/ ã«ç½®æ›ã—ã€æœ«å°¾ã« _spec ã‚’è¿½åŠ 
  let spec_file = substitute(current_file, '/app/', '/spec/', '')
  let spec_file = substitute(spec_file, '\.rb$', '_spec.rb', '')

  " ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
  if filereadable(spec_file)
    execute 'edit ' . spec_file
  else
    echo "Spec file not found: " . spec_file
  endif
endfunction

" å¯¾å¿œã—ãŸå®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
command! OpenImplementation :call OpenImplementationFile()

function! OpenImplementationFile()
  let current_file = expand('%:p')
  let impl_file = substitute(current_file, '/spec/', '/app/', '')
  let impl_file = substitute(impl_file, '_spec\.rb$', '.rb', '')

  if filereadable(impl_file)
    execute 'edit ' . impl_file
  else
    echo "Implementation file not found: " . impl_file
  endif
endfunction
